Redis的实现是基于 [Stripe](https://stripe.com/blog/rate-limiters) 的工作。它需要使用 spring-boot-starter-data-redis-reactive Spring Boot Starter。

使用的算法是 [令牌桶算法](https://en.wikipedia.org/wiki/Token_bucket)。

redis-rate-limiter.replenishRate 属性定义了每秒钟允许多少个请求（不算放弃的请求）。这是令牌桶被填充的速度。

redis-rate-limiter.burstCapacity 属性是一个用户在一秒钟内允许的最大请求数（不算放弃的请求）。这是令牌桶可以容纳的令牌数量。将此值设置为零会阻止所有请求。

redis-rate-limiter.requestedTokens 属性是指一个请求要花费多少令牌。这是为每个请求从桶中提取的令牌数量，默认为 1。

一个稳定的速率是通过在 replenishRate 和 burstCapacity 中设置相同的值来实现的。可以通过设置高于补给率的 burstCapacity 来允许临时的突发。在这种情况下，速率限制器需要在突发之间允许一些时间（根据 replenishRate），因为连续两次突发会导致请求被放弃（HTTP 429 - Too Many Requests）。下面的列表配置了一个 redis-rate-limiter。

低于 1个请求/s 的速率限制是通过将 replenishRate 设置为想要的请求数， requestTokens 设置为秒数，burstCapacity 设置为 replenishRate 和 requestTokens 的乘积来完成的。例如，设置 replenishRate=1，requestedTokens=60，burstCapacity=60，结果是1个请求/分钟的限制。

_Example 44. application.yml_

```plain
spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            redis-rate-limiter.replenishRate: 10
            redis-rate-limiter.burstCapacity: 20
            redis-rate-limiter.requestedTokens: 1
```



下面的例子在Java中配置了一个 KeyResolver。

_Example 45. Config.java_

```plain
@Bean
KeyResolver userKeyResolver() {
    return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst("user"));
}
```



这定义了每个用户的请求率限制为10。爆发20次是允许的，但是，在下一秒，只有10个请求可用。KeyResolver 是一个简单的，获得 user 请求参数。

| 不建议在生产中使用这个方法 |
| --- |


你也可以把速率限制器定义为一个实现 RateLimiter 接口的bean。在配置中，你可以用SpEL来引用bean的名字。#{@myRateLimiter} 是一个SpEL表达式，它引用了一个名为 myRateLimiter 的 bean。下面的清单定义了一个速率限制器，它使用了前面清单中定义的 KeyResolver。

_Example 46. application.yml_

```plain
spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            rate-limiter: "#{@myRateLimiter}"
            key-resolver: "#{@userKeyResolver}"
```



  


