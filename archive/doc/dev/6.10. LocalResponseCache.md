这个过滤器允许缓存响应体和header，遵循以下规则。

+ 它只能缓存无请求体的GET请求。
+ 它只对以下状态代码之一的响应进行缓存。HTTP 200（OK），HTTP 206（部分内容），或HTTP 301（永久移动）。
+ 如果 Cache-Control header不允许，响应数据就不会被缓存（请求中存在 no-store 或响应中存在 no-store 或 private）。
+ 如果响应已经被缓存，并且在 Cache-Control 头中用 no-cache 值执行一个新的请求，它将返回一个304（未修改）的无body的响应。

这个过滤器（配置每个路由的本地响应缓存）只有在启用了[本地响应全局缓存](https://springdoc.cn/spring-cloud-gateway/#local-cache-response-global-filter)的情况下才可用。

它接受第一个参数，用于覆盖缓存条目过期的时间（用 s 表示秒，用 m 表示分钟，用 h 表示小时），第二个参数用于设置该路由驱逐条目的最大缓存大小（KB、MB或GB）。

下面的列表显示了如何添加本地响应缓存 GatewayFilter。



```plain
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("rewrite_response_upper", r -> r.host("*.rewriteresponseupper.org")
            .filters(f -> f.prefixPath("/httpbin")
                .localResponseCache(Duration.ofMinutes(30), "500MB")
            ).uri(uri))
        .build();
}
```



或者，这样：

_application.yaml_

```plain
spring:
  cloud:
    gateway:
      routes:
      - id: resource
        uri: http://localhost:9000
        predicates:
        - Path=/resource
        filters:
        - LocalResponseCache=30m,500MB
```



| 这个过滤器还自动计算 HTTP Cache-Control header中的 max-age 值。只有在原始响应中存在 max-age 的情况下，才会用 timeToLive 配置参数中设置的秒数重写该值。在连续的调用中，这个值会以响应过期前的剩余秒数重新计算。 |
| --- |




