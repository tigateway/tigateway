| 下面描述的是另一种风格的网关。之前的文档都不适用于下面的内容。 |
| --- |


Spring Cloud Gateway 提供了一个名为 ProxyExchange 的实用对象。你可以在普通的 Spring web handler 中作为方法参数使用它。它通过反映 HTTP 动词的方法支持基本的下游 HTTP exchange。在MVC中，它还支持通过 forward() 方法转发到本地处理程序。要使用 ProxyExchange，在你的classpath中包含正确的模块（spring-cloud-gateway-mvc 或 spring-cloud-gateway-webflux）。

下面的MVC例子将一个到 /test 的请求代理到一个远程服务器。



```plain
@RestController
@SpringBootApplication
public class GatewaySampleApplication {

    @Value("${remote.home}")
    private URI home;

    @GetMapping("/test")
    public ResponseEntity<?> proxy(ProxyExchange<byte[]> proxy) throws Exception {
        return proxy.uri(home.toString() + "/image/png").get();
    }

}
```



下面的例子用Webflux实现相同的效果。



```plain
@RestController
@SpringBootApplication
public class GatewaySampleApplication {

    @Value("${remote.home}")
    private URI home;

    @GetMapping("/test")
    public Mono<ResponseEntity<?>> proxy(ProxyExchange<byte[]> proxy) throws Exception {
        return proxy.uri(home.toString() + "/image/png").get();
    }

}
```



ProxyExchange 上的便利方法使处理方法能够发现并增强传入请求的URI路径。例如，你可能想提取路径的尾部元素，将它们传递到下游。



```plain
@GetMapping("/proxy/path/**")
public ResponseEntity<?> proxyPath(ProxyExchange<byte[]> proxy) throws Exception {
  String path = proxy.path("/proxy/path/");
  return proxy.uri(home.toString() + "/foos/" + path).get();
}
```



Spring MVC和Webflux的所有功能都可用于网关 handler method。因此，你可以注入请求头和查询参数，例如，你可以通过 mapping 注解中的声明来限制传入的请求。关于这些功能的更多细节，请参见Spring MVC中的 @RequestMapping 文档。

你可以通过使用 ProxyExchange 的 header() 方法在下游响应中添加头信息。

你也可以通过给 get() 方法（和其他方法）添加一个 mapper 来操作响应头（以及 response 中你喜欢的其他东西）。mapper 是一个 Function，它接收传入的 ResponseEntity 并将其转换为传出的。

对 "敏感" header（默认为 cookie 和 授 authorization）和 “proxy”（x-forwarded-*）header 提供了一流的支持，这些标头不会被传递到下游。

